/* Include file below is generated by C-Builder    */
/* and contains the variables declared as -        */
/* PARAMETERS, INPUTS, OUTPUTS . . .               */
#include "SFCLphT0.h"


STATIC:
/* ----------------------------------------------- */
/* Variables declared here may be used in both the */
/* RAM: and CODE: sections below.                  */
/* ----------------------------------------------- */
double dt;
int phase = 0;
int newState[3];
int locked = 0;
double RsfclNew[3];		// history of Rsfcl values for averaging
double Qremoved[3];
double Qsc[3];
double QscDiff[3];
double QremovedDiff[3];
double newJ[3];
double newE[3];         // store the E-field value from the previous iteration
double T[3];												// the instantaneous temperature of the superconductor
double Jc[3];
double current[3];
double sc_length;                          				// note that the SC diameter is simply multiplied by this number.
double sc_diameter;                            			// superconductor diameter (m)
double sc_area;	// superconductor cross-sectional area (m^2)
double Cv;
double k;
double Csc;
double Rsc;   // includes the total surface area (minus the wire "ends")
double alpha;
double alpha_alt;
double calculation1[3];
double calculation2[3];
double alt1, alt2, alt3;
double minValue = 1;

// superconductor characteristics
double Jc_77K = 1.5e7;               // critical current density at 77K (A/m^2)
double E0 = 0.1;                     // E-field for transition from superconducting state to flux-flow state (V/m)
double Ec = 0.0001;              	 // definition of E-field required for Jc (V/m) (Ec = 1e-6 * 100)
double alpha_77K = 6.0;              // exponent value during superconducting state (dimensionless)
double beta = 3;                     // exponent value during flux-flow state (dimensionless)
double Tc = 95;                      // critical temperature (K)
double rho_Tc = 1.0e-6;              // superconductor resistivity at Tc (ohm-m^2)
/* - E n d   o f   S T A T I C :   S e c t i o n - */

RAM_FUNCTIONS:

/* ----------------------------------------------- */
/* This section should contain any 'c' functions   */
/* to be called from the RAM section (either       */
/* RAM_PASS1 or RAM_PASS2). Example:               */
/*                                                 */
/* static double myFunction(double v1, double v2)  */
/* {                                               */
/*     return(v1*v2);                              */
/* }                                               */
/* ----------------------------------------------- */

RAM:

/* ----------------------------------------------- */
/* Place C code here which computes constants      */
/* required for the CODE: section below.  The C    */
/* code here is executed once, prior to the start  */
/* of the simulation case.                         */
/* ----------------------------------------------- */

for (phase = 0; phase < 3; phase++) {//maxLoopCount = 3
    RsfclNew[phase] = 1e-3;
    T[phase] = Ta;                                                 // the instantaneous temperature of the superconductor
    calculation1[phase] = pow((Ec / E0), (beta/alpha_77K));
    calculation2[phase] = pow((E0 / Ec), (1 / alpha_77K));
    newState[phase] = 0;
}
dt = getTimeStep();
sc_length = 50.0;                          				// note that the SC diameter is simply multiplied by this number.
sc_diameter = 0.004;                            			// superconductor diameter (m)
sc_area = PI * (sc_diameter / 2) * (sc_diameter / 2);	// superconductor cross-sectional area (m^2)
Cv = 1.0e6;
k = 1.5e3;
Csc = sc_length * sc_area * Cv;
Rsc = 1 / (k * sc_length * sc_diameter * PI);   // includes the total surface area (minus the "ends")

alt1 = log10(E0 / Ec);
alt2 = (1 - (1/beta));
//nominal_resistance = rho_Tc * sc_length / sc_area;  // SFCL resistance at temperature=Tc

/* ---- E n d   o f   R A M :   S e c t i o n ---- */

CODE:

BEGIN_T0:
/* ----------------------------------------------- */
/* Place C code here which runs on the RTDS. The   */
/* code below is entered once each simulation      */
/* step.                                           */
/* ----------------------------------------------- */

if (enable == 1) {
    // read inputs
    if (reset >= 1) {
        locked = 0;
        //quenched = 0;
    }
    current[0] = 1000 * i1; // convert to amps
    current[1] = 1000 * i2;
    current[2] = 1000 * i3;

    for (phase = 0; phase < 3; phase++) {//maxLoopCount = 3

        // inputs from power system
        newJ[phase] = fabs(current[phase]) / sc_area;

        if (T[phase] < Tc) {
            if (newE[phase] < E0) {
                // superconducting
                newState[phase] = 0;
            }
            else {
                // flux-flow
                newState[phase] = 1;
            }
            
            Jc[phase] = Jc_77K * ((Tc - T[phase]) / (Tc - 77));
        }
        else {
            // normal conducting
            newState[phase] = 2;
            
            Jc[phase] = Jc_77K;    // value of Jc does not matter if T >= Tc
        }

        if (Jc[phase] > (minValue / sc_area)) {
            alt3 = Jc_77K / Jc[phase];
        }

        alpha_alt = alt1 / fmax(log10( fmax(pow(alt3, alt2) * calculation2[phase], minValue) ), minValue);   // avoid division by zero
        alpha = fmax(beta, alpha_alt);

        if (newState[phase] == 0) {
            // superconducting
            newE[phase] = Ec * pow((newJ[phase] / fmax(Jc[phase], (minValue / sc_area))), alpha);
        }
        else if (newState[phase] == 1) {
            // flux-flow
            newE[phase] = E0 * calculation1[phase] * (Jc_77K / fmax(Jc[phase], minValue)) * pow((newJ[phase] / Jc_77K), beta);
        }
        else {
            // normal conducting
            newE[phase] = rho_Tc * (T[phase] / Tc) * newJ[phase];
            RsfclNew[phase] = rho_Tc * (T[phase] / Tc) * sc_length / sc_area;
        }

        // assume that if the flux-flow resistance >= the equivalent normal state resitance, then the superconductor has quenched
        double quenchedR = rho_Tc * (T[phase] / Tc) * sc_length / sc_area;
        if ((newState[phase] == 1 || newState[phase] == 2) && RsfclNew[phase] >= quenchedR) {
            newState[phase] = 2;
            RsfclNew[phase] = quenchedR;
        }

        // ensure current is non-zero before division
        if (fabs(current[phase]) > minValue) {
            RsfclNew[phase] = newE[phase] * sc_length / fabs(current[phase]);
        }
        else {
            if (newState[phase] == 0) {
                RsfclNew[phase] = 1e-6;
            }
        }

        // thermal calculations
        QscDiff[phase] = current[phase] * current[phase] * RsfclNew[phase] * dt;
        QremovedDiff[phase] = ((T[phase] - Ta) / Rsc) * dt;
        Qsc[phase] = Qsc[phase] + QscDiff[phase];
        Qremoved[phase] = Qremoved[phase] + QremovedDiff[phase];


        T[phase] = T[phase] + (Qsc[phase] - Qremoved[phase]) / Csc;         // slight difference from [Langston2005]: Ta replaced by T[phase]
        Qsc[phase] = 0.0;
        Qremoved[phase] = 0.0;
    }

    // set new component phase conductance
    GRVAL = 1.0 / RsfclNew[0];
    GRVAL2 = 1.0 / RsfclNew[1];
    GRVAL3 = 1.0 / RsfclNew[2];

    // set "quenched" output if any phase has quenched
    if (locked == 0) {
        if (newState[0] == 2 || newState[1] == 2 || newState[2] == 2) {
            quenched = 1;
            locked = 1;
        }
        else {
            quenched = 0;
        }
    }
}
else {
    // set default component phase conductance (when SFCL is disabled)
    GRVAL = 1.0e6;
    GRVAL2 = 1.0e6;
    GRVAL3 = 1.0e6;
}

// other outputs (monitored variables)
R1 = RsfclNew[0];
R2 = RsfclNew[1];
R3 = RsfclNew[2];

T1 = T[0];
T2 = T[1];
T3 = T[2];

state1 = newState[0];
state2 = newState[1];
state3 = newState[2];

/* ---- E n d   o f   C O D E :  S e c t i o n --- */